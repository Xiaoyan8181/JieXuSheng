<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>早起的寶兒有沖砍</title>
    <style>
        canvas {
            border: 1px solid black;
            float: left;
            display: none;
        }
        #score, #buffs, #timer, #combo {
            font-size: 24px;
            margin-left: 20px;
            display: inline-block;
            display: none;
        }
        #combo {
            position: fixed;
            top: 10px;
            right: 10px;
        }
        #title {
            text-align: center;
            font-size: 36px;
            margin-top: 10px;
        }
        #menu {
            text-align: center;
            margin-top: 20px;
        }
        #menu button {
            font-size: 20px;
            margin: 10px 0;
            padding: 10px 20px;
            display: block;
            width: 200px;
            margin-left: auto;
            margin-right: auto;
        }
        #leaderboard, #nameInput {
            display: none;
            text-align: center;
            margin-top: 20px;
        }
        #baoAnimation {
            position: fixed;
            bottom: 10px;
            right: 10px;
            width: 200px;
            height: 200px;
        }
        #swordAnimation {
            position: fixed;
            bottom: 10px;
            left: 10px;
            width: 200px;
            height: 200px;
            animation: rotate 2s linear infinite;
        }
        @keyframes rotate {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>
<body>
    <div id="title">早起的寶兒有沖砍</div>
    <canvas id="gameCanvas" width="800" height="800"></canvas>
    <div id="score">分數: 0</div>
    <div id="buffs">BUFF: 無</div>
    <div id="timer">剩餘時間: 60</div>
    <div id="combo">COMBO: 0</div>

    <div id="menu">
        <button onclick="startGame()">開始遊戲</button>
        <button onclick="showLeaderboard()">排行榜</button>
        <button onclick="window.close()">離開</button>
    </div>
    <div id="leaderboard">
        <h2>排行榜</h2>
        <div id="leaderboardList"></div>
        <button onclick="backToMenu()">返回</button>
    </div>
    <div id="nameInput">
        <h2>遊戲結束！你的分數: <span id="finalScore"></span></h2>
        <input type="text" id="playerName" placeholder="輸入你的名稱" maxlength="20">
        <button onclick="saveScore()">提交</button>
    </div>

    <img id="baoAnimation" src="./images/大寶.gif" alt="大寶">
    <img id="swordAnimation" src="./images/古錠刀.png" alt="古錠刀">

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const buffsDisplay = document.getElementById('buffs');
        const timerDisplay = document.getElementById('timer');
        const comboDisplay = document.getElementById('combo');
        const menu = document.getElementById('menu');
        const leaderboard = document.getElementById('leaderboard');
        const leaderboardList = document.getElementById('leaderboardList');
        const nameInput = document.getElementById('nameInput');
        const finalScoreDisplay = document.getElementById('finalScore');
        const baoAnimation = document.getElementById('baoAnimation');
        const swordAnimation = document.getElementById('swordAnimation');

        // 載入圖片和音效
        const playerImage = new Image();
        playerImage.src = './images/大寶.gif';
        const enemyImage = new Image();
        enemyImage.src = './images/沖兒.png';
        const caoAngImage = new Image();
        caoAngImage.src = './images/曹昂.png';
        const wineImage = new Image();
        wineImage.src = './images/酒.png';
        const fireKillImage = new Image();
        fireKillImage.src = './images/火殺.png';
        const ancientSwordImage = new Image();
        ancientSwordImage.src = './images/古錠刀.png';
        const holeImage = new Image();
        holeImage.src = './images/Hole.png';
        const hitSound = new Audio('./audio/萬軍取首.mp3');
        const slaughterSound = new Audio('./audio/癲狂屠戮.mp3');
        const flashSound = new Audio('./audio/閃.mp3');
        const wineSound = new Audio('./audio/酒.mp3');
        const fireKillSound = new Audio('./audio/火殺.mp3');
        const equipSound = new Audio('./audio/equip.mp3');
        const bgm = new Audio('./audio/BGM.mp3');
        bgm.loop = true;

        // 主角物件
        const player = {
            x: 400,
            y: 400,
            speed: 0,
            maxSpeed: 8,
            acceleration: 0.1,
            deceleration: 0.1,
            targetX: 400,
            targetY: 400,
            size: 80,
            moving: false,
            facingRight: false
        };

        // 邊界範圍
        const boundary = {
            minX: 0,
            minY: 0,
            maxX: canvas.width,
            maxY: canvas.height
        };

        // 分數、BUFF 和 COMBO 狀態
        let score = 0;
        let wineBuff = false;
        let fireKillBuff = false;
        let ancientSwordDurability = 0;
        let comboCount = 0;
        let timeLeft = 60;
        let gameActive = false;
        let spawnInterval;

        // 檢測是否為觸控裝置
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

        // 洞的陣列
        const holes = [];
        const holeRadius = 30;

        // 敵人（沖兒）和曹昂陣列
        const enemies = [];
        const caoAngs = [];
        const enemySize = 45;

        // 道具陣列
        const items = [];
        const itemSize = 45;

        // 更新 COMBO 顯示
        function updateComboDisplay() {
            let comboText = `COMBO: ${comboCount}`;
            if (comboCount === 1) comboText += " 一破 臥龍出山";
            else if (comboCount === 2) comboText += " 雙連 一戰成名";
            else if (comboCount === 3) comboText += " 三連 舉世皆驚";
            else if (comboCount === 4) comboText += " 四連 天下無敵";
            else if (comboCount >= 5) comboText += " 誅天滅地";
            comboDisplay.textContent = comboText;
            console.log(`更新 COMBO 顯示: ${comboText}`);
        }

        // 更新主角位置
        function updatePlayer() {
            const dx = player.targetX - player.x;
            const dy = player.targetY - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < 1) {
                player.x = player.targetX;
                player.y = player.targetY;
                player.speed = 0;
                player.moving = false;
                return;
            }

            const angle = Math.atan2(dy, dx);
            const targetSpeed = distance < 50 ? distance / 10 : player.maxSpeed;

            if (player.speed < targetSpeed) {
                player.speed = Math.min(player.speed + player.acceleration, targetSpeed);
            } else {
                player.speed = Math.max(player.speed - player.deceleration, targetSpeed);
            }

            player.x += Math.cos(angle) * player.speed;
            player.y += Math.sin(angle) * player.speed;

            player.x = Math.max(boundary.minX + player.size / 2, Math.min(boundary.maxX - player.size / 2, player.x));
            player.y = Math.max(boundary.minY + player.size / 2, Math.min(boundary.maxY - player.size / 2, player.y));
            player.facingRight = player.targetX > player.x;
        }

        // 生成敵人（沖兒）
        function spawnEnemy() {
            const holeIndex = Math.floor(Math.random() * holes.length);
            const hole = holes[holeIndex];
            const angle = Math.random() * Math.PI * 2;
            const spawnDistance = holeRadius + enemySize / 2;
            const isLarge = Math.random() < 0.10;
            const enemy = {
                x: hole.x + Math.cos(angle) * spawnDistance,
                y: hole.y + Math.sin(angle) * spawnDistance,
                speed: 0,
                maxSpeed: isLarge ? 1.25 : 2.5,
                acceleration: 0.2,
                delay: 1000,
                targetX: 0,
                targetY: 0,
                size: isLarge ? enemySize * 2 : enemySize,
                holeIndex: holeIndex,
                hp: isLarge ? 2 : 1,
                isLarge: isLarge
            };

            const escapeAngle = Math.random() * Math.PI * 2;
            const escapeDistance = 1000;
            enemy.targetX = enemy.x + Math.cos(escapeAngle) * escapeDistance;
            enemy.targetY = enemy.y + Math.sin(escapeAngle) * escapeDistance;

            enemies.push(enemy);
            console.log(`生成敵人: ${isLarge ? '大沖兒' : '普通沖兒'}, 位置: (${enemy.x}, ${enemy.y})`);
            return holeIndex;
        }

        // 生成曹昂
        function spawnCaoAng(excludeHoleIndex) {
            let holeIndex;
            do {
                holeIndex = Math.floor(Math.random() * holes.length);
            } while (holeIndex === excludeHoleIndex);

            const hole = holes[holeIndex];
            const angle = Math.random() * Math.PI * 2;
            const spawnDistance = holeRadius + enemySize / 2;
            const caoAng = {
                x: hole.x + Math.cos(angle) * spawnDistance,
                y: hole.y + Math.sin(angle) * spawnDistance,
                speed: 0,
                maxSpeed: 2.5,
                acceleration: 0.2,
                delay: 1000,
                targetX: 0,
                targetY: 0,
                size: enemySize
            };

            const escapeAngle = Math.random() * Math.PI * 2;
            const escapeDistance = 1000;
            caoAng.targetX = caoAng.x + Math.cos(escapeAngle) * escapeDistance;
            caoAng.targetY = caoAng.y + Math.sin(escapeAngle) * escapeDistance;

            caoAngs.push(caoAng);
            console.log(`生成曹昂, 位置: (${caoAng.x}, ${caoAng.y})`);
        }

        // 生成道具
        function spawnItem() {
            const rand = Math.random();
            let itemType, itemImage;
            if (rand < 0.52) {
                itemType = 'wine';
                itemImage = wineImage;
            } else if (rand < 0.99) {
                itemType = 'fireKill';
                itemImage = fireKillImage;
            } else {
                itemType = 'ancientSword';
                itemImage = ancientSwordImage;
            }

            const item = {
                x: Math.random() * (boundary.maxX - itemSize) + itemSize / 2,
                y: Math.random() * (boundary.maxY - itemSize) + itemSize / 2,
                size: itemSize,
                type: itemType,
                image: itemImage
            };
            items.push(item);
            console.log(`生成道具: ${itemType}, 位置: (${item.x}, ${item.y})`);
        }

        // 更新敵人（沖兒）位置
        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];

                if (enemy.delay > 0) {
                    enemy.delay -= 1000 / 60;
                    continue;
                }

                const dx = enemy.targetX - enemy.x;
                const dy = enemy.targetY - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 1 || enemy.x < boundary.minX || enemy.x > boundary.maxX || enemy.y < boundary.minY || enemy.y > boundary.maxY) {
                    enemies.splice(i, 1);
                    continue;
                }

                const angle = Math.atan2(dy, dx);
                enemy.speed = Math.min(enemy.speed + enemy.acceleration, enemy.maxSpeed);
                enemy.x += Math.cos(angle) * enemy.speed;
                enemy.y += Math.sin(angle) * enemy.speed;

                const playerDx = player.x - enemy.x;
                const playerDy = player.y - enemy.y;
                const playerDistance = Math.sqrt(playerDx * playerDx + playerDy * playerDy);
                if (playerDistance < (player.size + enemy.size) / 2) {
                    enemy.hp--;
                    console.log(`擊中敵人, HP: ${enemy.hp}`);
                    if (enemy.hp <= 0) {
                        enemies.splice(i, 1);
                        comboCount++;
                        if (wineBuff || fireKillBuff || ancientSwordDurability > 0) {
                            hitSound.play();
                        } else {
                            slaughterSound.play();
                        }
                        let baseScore = enemy.isLarge ? 3 : 1;
                        baseScore += (wineBuff ? 1 : 0) + (fireKillBuff ? 1 : 0);
                        let totalScore = ancientSwordDurability > 0 ? baseScore * 2 : baseScore;
                        totalScore += comboCount;
                        score += totalScore;
                        if (wineBuff) wineBuff = false;
                        if (fireKillBuff) fireKillBuff = false;
                        if (ancientSwordDurability > 0) ancientSwordDurability = Math.max(0, ancientSwordDurability - 5);
                        updateBuffDisplay();
                        updateComboDisplay();
                        scoreDisplay.textContent = `分數: ${score}`;
                        console.log(`擊殺敵人, COMBO: ${comboCount}, 分數增加: ${totalScore}`);
                    }
                }
            }
        }

        // 更新曹昂位置
        function updateCaoAngs() {
            for (let i = caoAngs.length - 1; i >= 0; i--) {
                const caoAng = caoAngs[i];

                if (caoAng.delay > 0) {
                    caoAng.delay -= 1000 / 60;
                    continue;
                }

                const dx = caoAng.targetX - caoAng.x;
                const dy = caoAng.targetY - caoAng.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 1 || caoAng.x < boundary.minX || caoAng.x > boundary.maxX || caoAng.y < boundary.minY || caoAng.y > boundary.maxY) {
                    caoAngs.splice(i, 1);
                    continue;
                }

                const angle = Math.atan2(dy, dx);
                caoAng.speed = Math.min(caoAng.speed + caoAng.acceleration, caoAng.maxSpeed);
                caoAng.x += Math.cos(angle) * caoAng.speed;
                caoAng.y += Math.sin(angle) * caoAng.speed;

                const playerDx = player.x - caoAng.x;
                const playerDy = player.y - caoAng.y;
                const playerDistance = Math.sqrt(playerDx * playerDx + playerDy * playerDy);
                if (playerDistance < (player.size + caoAng.size) / 2) {
                    caoAngs.splice(i, 1);
                    flashSound.play();
                    comboCount = 0;
                    if (wineBuff) wineBuff = false;
                    if (fireKillBuff) fireKillBuff = false;
                    if (ancientSwordDurability > 0) ancientSwordDurability = Math.max(0, ancientSwordDurability - 5);
                    updateBuffDisplay();
                    updateComboDisplay();
                    console.log('碰到曹昂，COMBO 重置為 0');
                }
            }
        }

        // 更新道具
        function updateItems() {
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                const dx = player.x - item.x;
                const dy = player.y - item.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < (player.size + item.size) / 2) {
                    items.splice(i, 1);
                    if (item.type === 'wine') {
                        wineBuff = true;
                        wineSound.play();
                    } else if (item.type === 'fireKill') {
                        fireKillBuff = true;
                        fireKillSound.play();
                    } else if (item.type === 'ancientSword') {
                        ancientSwordDurability = 100;
                        equipSound.play();
                    }
                    updateBuffDisplay();
                }
            }
        }

        // 更新 BUFF 顯示
        function updateBuffDisplay() {
            let buffs = [];
            if (wineBuff) buffs.push('酒');
            if (fireKillBuff) buffs.push('火殺');
            if (ancientSwordDurability > 0) buffs.push(`古錠刀 (${ancientSwordDurability}%)`);
            buffsDisplay.textContent = `BUFF: ${buffs.length > 0 ? buffs.join(', ') : '無'}`;
            console.log(`更新 BUFF 顯示: ${buffsDisplay.textContent}`);
        }

        // 繪製遊戲畫面
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameActive) {
                for (const hole of holes) {
                    if (holeImage.complete) {
                        ctx.drawImage(holeImage, hole.x - holeRadius, hole.y - holeRadius, holeRadius * 2, holeRadius * 2);
                    } else {
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(hole.x, hole.y, holeRadius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.closePath();
                    }
                }

                for (const item of items) {
                    if (item.image.complete) {
                        ctx.drawImage(item.image, item.x - item.size / 2, item.y - item.size / 2, item.size, item.size);
                    } else {
                        ctx.fillStyle = 'yellow';
                        ctx.fillRect(item.x - item.size / 2, item.y - item.size / 2, item.size, item.size);
                    }
                }

                for (const enemy of enemies) {
                    if (enemyImage.complete) {
                        ctx.drawImage(enemyImage, enemy.x - enemy.size / 2, enemy.y - enemy.size / 2, enemy.size, enemy.size);
                    } else {
                        ctx.fillStyle = 'green';
                        ctx.fillRect(enemy.x - enemy.size / 2, enemy.y - enemy.size / 2, enemy.size, enemy.size);
                    }
                }

                for (const caoAng of caoAngs) {
                    if (caoAngImage.complete) {
                        ctx.drawImage(caoAngImage, caoAng.x - caoAng.size / 2, caoAng.y - caoAng.size / 2, caoAng.size, caoAng.size);
                    } else {
                        ctx.fillStyle = 'purple';
                        ctx.fillRect(caoAng.x - caoAng.size / 2, caoAng.y - caoAng.size / 2, caoAng.size, caoAng.size);
                    }
                }

                if (playerImage.complete) {
                    ctx.save();
                    ctx.translate(player.x, player.y);
                    if (player.facingRight) {
                        ctx.scale(-1, 1);
                    }
                    ctx.drawImage(playerImage, -player.size / 2, -player.size / 2, player.size, player.size);
                    ctx.restore();
                } else {
                    ctx.fillStyle = 'red';
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                }
            }
        }

        // 遊戲主迴圈
        function gameLoop() {
            if (gameActive) {
                updatePlayer();
                updateEnemies();
                updateCaoAngs();
                updateItems();
                baoAnimation.style.display = 'none';
                swordAnimation.style.display = 'none';
            } else {
                baoAnimation.style.display = 'block';
                swordAnimation.style.display = 'block';
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        // 隨機生成不重疊的洞
        function generateHoles() {
            const centerArea = { minX: 250, maxX: 550, minY: 250, maxY: 550 };
            while (holes.length < 3) {
                const newHole = {
                    x: Math.random() * (centerArea.maxX - centerArea.minX - 2 * holeRadius) + centerArea.minX + holeRadius,
                    y: Math.random() * (centerArea.maxY - centerArea.minY - 2 * holeRadius) + centerArea.minY + holeRadius
                };
                let overlapping = false;
                for (const hole of holes) {
                    const dx = newHole.x - hole.x;
                    const dy = newHole.y - hole.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < holeRadius * 2) {
                        overlapping = true;
                        break;
                    }
                }
                if (!overlapping) {
                    holes.push(newHole);
                    console.log(`生成洞: (${newHole.x}, ${newHole.y})`);
                }
            }
        }

        // 滑鼠移動事件（PC）
        if (!isTouchDevice) {
            canvas.addEventListener('mousemove', (event) => {
                if (!gameActive) return;
                const rect = canvas.getBoundingClientRect();
                player.targetX = Math.max(boundary.minX + player.size / 2, Math.min(boundary.maxX - player.size / 2, event.clientX - rect.left));
                player.targetY = Math.max(boundary.minY + player.size / 2, Math.min(boundary.maxY - player.size / 2, event.clientY - rect.top));
                console.log(`滑鼠移動至: (${player.targetX}, ${player.targetY})`);
            });
        }

        // 觸控事件（手機）
        if (isTouchDevice) {
            canvas.addEventListener('touchstart', (event) => {
                if (!gameActive) return;
                event.preventDefault();
                const touch = event.touches[0];
                const rect = canvas.getBoundingClientRect();
                player.targetX = Math.max(boundary.minX + player.size / 2, Math.min(boundary.maxX - player.size / 2, touch.clientX - rect.left));
                player.targetY = Math.max(boundary.minY + player.size / 2, Math.min(boundary.maxY - player.size / 2, touch.clientY - rect.top));
                player.moving = true;
                console.log(`觸控移動至: (${player.targetX}, ${player.targetY})`);
            });

            canvas.addEventListener('touchmove', (event) => {
                if (!gameActive) return;
                event.preventDefault();
                const touch = event.touches[0];
                const rect = canvas.getBoundingClientRect();
                player.targetX = Math.max(boundary.minX + player.size / 2, Math.min(boundary.maxX - player.size / 2, touch.clientX - rect.left));
                player.targetY = Math.max(boundary.minY + player.size / 2, Math.min(boundary.maxY - player.size / 2, touch.clientY - rect.top));
                console.log(`觸控移動至: (${player.targetX}, ${player.targetY})`);
            });
        }

        // 開始遊戲
        function startGame() {
            console.log('點擊開始遊戲');
            menu.style.display = 'none';
            canvas.style.display = 'block';
            scoreDisplay.style.display = 'inline-block';
            buffsDisplay.style.display = 'inline-block';
            timerDisplay.style.display = 'inline-block';
            comboDisplay.style.display = 'inline-block';

            score = 0;
            wineBuff = false;
            fireKillBuff = false;
            ancientSwordDurability = 0;
            comboCount = 0;
            timeLeft = 60;
            gameActive = true;
            enemies.length = 0;
            caoAngs.length = 0;
            items.length = 0;
            holes.length = 0;
            generateHoles();
            scoreDisplay.textContent = `分數: ${score}`;
            updateBuffDisplay();
            updateComboDisplay();
            timerDisplay.textContent = `剩餘時間: ${Math.ceil(timeLeft)}`;

            bgm.play();
            console.log('遊戲開始，生成洞數量: ' + holes.length);

            spawnInterval = setInterval(() => {
                const enemyHoleIndex = spawnEnemy();
                if (Math.random() < 0.30) spawnCaoAng(enemyHoleIndex);
                if (Math.random() < 0.20) spawnItem();

                timeLeft -= 0.5;
                timerDisplay.textContent = `剩餘時間: ${Math.ceil(timeLeft)}`;
                console.log(`時間更新: ${timeLeft}, 敵人數量: ${enemies.length}, 曹昂數量: ${caoAngs.length}, 道具數量: ${items.length}`);
                if (timeLeft <= 0) endGame();
            }, 500);
        }

        // 結束遊戲
        function endGame() {
            gameActive = false;
            clearInterval(spawnInterval);
            canvas.style.display = 'none';
            scoreDisplay.style.display = 'none';
            buffsDisplay.style.display = 'none';
            timerDisplay.style.display = 'none';
            comboDisplay.style.display = 'none';
            nameInput.style.display = 'block';
            finalScoreDisplay.textContent = score;
            bgm.pause();
            bgm.currentTime = 0;
            console.log('遊戲結束');
            baoAnimation.style.display = 'block';
            swordAnimation.style.display = 'block';
        }

        // 儲存分數到排行榜
        function saveScore() {
            const name = document.getElementById('playerName').value.trim();
            if (!name) return alert('請輸入名稱！');

            let leaderboardData = JSON.parse(localStorage.getItem('leaderboard') || '[]');
            leaderboardData.push({ name, score });
            leaderboardData.sort((a, b) => b.score - a.score);
            leaderboardData = leaderboardData.slice(0, 10);
            localStorage.setItem('leaderboard', JSON.stringify(leaderboardData));

            nameInput.style.display = 'none';
            showLeaderboard();
        }

        // 顯示排行榜
        function showLeaderboard() {
            menu.style.display = 'none';
            leaderboard.style.display = 'block';
            const leaderboardData = JSON.parse(localStorage.getItem('leaderboard') || '[]');
            leaderboardList.innerHTML = leaderboardData.length > 0
                ? leaderboardData.map((entry, index) => `${index + 1}. ${entry.name}: ${entry.score}`).join('<br>')
                : '尚無紀錄';
            baoAnimation.style.display = 'block';
            swordAnimation.style.display = 'block';
        }

        // 返回主選單
        function backToMenu() {
            leaderboard.style.display = 'none';
            menu.style.display = 'block';
            baoAnimation.style.display = 'block';
            swordAnimation.style.display = 'block';
        }

        // 初始化並啟動遊戲主迴圈
        console.log('初始化遊戲');
        gameLoop();
    </script>
</body>
</html>
