<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>早起的寶兒有沖砍</title>
    <style>
        canvas {
            border: 1px solid black;
            float: left;
            display: none;
        }
        #score, #buffs, #timer, #combo {
            font-size: 24px;
            margin-left: 20px;
            display: inline-block;
            display: none;
        }
        #combo {
            position: fixed;
            top: 10px;
            right: 10px;
        }
        #title {
            text-align: center;
            font-size: 36px;
            margin-top: 10px;
        }
        #menu {
            text-align: center;
            margin-top: 20px;
            position: relative;
            width: 800px;
            height: 800px;
            margin-left: auto;
            margin-right: auto;
        }
        #menu button {
            font-size: 20px;
            margin: 10px 0;
            padding: 10px 20px;
            display: block;
            width: 200px;
            margin-left: auto;
            margin-right: auto;
        }
        #leaderboard, #nameInput {
            display: none;
            text-align: center;
            margin-top: 20px;
        }
        #baoAnimation {
            position: fixed;
            bottom: 10px;
            right: 10px;
            width: 200px;
            height: 200px;
            z-index: 10;
        }
        #swordAnimation {
            position: fixed;
            bottom: 10px;
            left: 10px;
            width: 200px;
            height: 200px;
            animation: rotate 2s linear infinite;
        }
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="title">早起的寶兒有沖砍</div>
    <canvas id="gameCanvas" width="800" height="800"></canvas>
    <div id="score">分數: 0</div>
    <div id="buffs">BUFF: 無</div>
    <div id="timer">剩餘時間: 60</div>
    <div id="combo">COMBO: 0</div>

    <div id="menu">
        <button onclick="startGame()">開始遊戲</button>
        <button onclick="showLeaderboard()">排行榜</button>
        <button onclick="window.close()">離開</button>
    </div>
    <div id="leaderboard">
        <h2>排行榜</h2>
        <div id="leaderboardList"></div>
        <button onclick="backToMenu()">返回</button>
    </div>
    <div id="nameInput">
        <h2>遊戲結束！你的分數: <span id="finalScore"></span></h2>
        <input type="text" id="playerName" placeholder="輸入你的名稱" maxlength="20">
        <button onclick="saveScore()">提交</button>
    </div>

    <img id="baoAnimation" src="./images/大寶.gif" alt="大寶">
    <img id="swordAnimation" src="./images/古錠刀.png" alt="古錠刀">

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const buffsDisplay = document.getElementById('buffs');
        const timerDisplay = document.getElementById('timer');
        const comboDisplay = document.getElementById('combo');
        const menu = document.getElementById('menu');
        const leaderboard = document.getElementById('leaderboard');
        const leaderboardList = document.getElementById('leaderboardList');
        const nameInput = document.getElementById('nameInput');
        const finalScoreDisplay = document.getElementById('finalScore');
        const baoAnimation = document.getElementById('baoAnimation');
        const swordAnimation = document.getElementById('swordAnimation');

        // 載入圖片和音效
        const playerImage = new Image(); playerImage.src = './images/大寶.gif';
        const enemyImage = new Image(); enemyImage.src = './images/沖兒.png';
        const caoAngImage = new Image(); caoAngImage.src = './images/曹昂.png';
        const wineImage = new Image(); wineImage.src = './images/酒.png';
        const fireKillImage = new Image(); fireKillImage.src = './images/火殺.png';
        const ancientSwordImage = new Image(); ancientSwordImage.src = './images/古錠刀.png';
        const holeImage = new Image(); holeImage.src = './images/Hole.png';
        const hitSound = new Audio('./audio/萬軍取首.mp3');
        const slaughterSound = new Audio('./audio/癲狂屠戮.mp3');
        const flashSound = new Audio('./audio/閃.mp3');
        const wineSound = new Audio('./audio/酒.mp3');
        const fireKillSound = new Audio('./audio/火殺.mp3');
        const equipSound = new Audio('./audio/equip.mp3');
        const bgm = new Audio('./audio/BGM.mp3');
        const minusOneSound = new Audio('./audio/-1.mp3');
        const minusTwoSound = new Audio('./audio/-2.mp3');
        const fireMinusTwoSound = new Audio('./audio/火-2.mp3');
        bgm.loop = true;

        // 主角物件
        const player = {
            x: 400, y: 400, speed: 0, maxSpeed: 8, acceleration: 0.1, deceleration: 0.1,
            targetX: 400, targetY: 400, size: 80, moving: false, facingRight: false
        };

        // 邊界範圍
        const boundary = { minX: 0, minY: 0, maxX: canvas.width, maxY: canvas.height };

        // 分數、BUFF 和 COMBO 狀態
        let score = 0, wineBuff = false, fireKillBuff = false, ancientSwordDurability = 0,
            comboCount = 0, timeLeft = 60, gameActive = false, spawnInterval;

        // 檢測是否為觸控裝置
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

        // 洞、敵人和道具陣列
        const holes = [], holeRadius = 30;
        const enemies = [], caoAngs = [], enemySize = 45;
        const items = [], itemSize = 45;

        // 更新 COMBO 顯示
        function updateComboDisplay() {
            let comboText = `COMBO: ${comboCount}`;
            if (comboCount === 1) comboText += " 一破 臥龍出山";
            else if (comboCount === 2) comboText += " 雙連 一戰成名";
            else if (comboCount === 3) comboText += " 三連 舉世皆驚";
            else if (comboCount === 4) comboText += " 四連 天下無敵";
            else if (comboCount >= 5) comboText += " 誅天滅地";
            comboDisplay.textContent = comboText;
        }

        // 更新主角位置
        function updatePlayer() {
            const dx = player.targetX - player.x;
            const dy = player.targetY - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < 1) {
                player.x = player.targetX;
                player.y = player.targetY;
                player.speed = 0;
                player.moving = false;
                return;
            }

            const angle = Math.atan2(dy, dx);
            const targetSpeed = distance < 50 ? distance / 10 : player.maxSpeed;

            if (player.speed < targetSpeed) {
                player.speed = Math.min(player.speed + player.acceleration, targetSpeed);
            } else {
                player.speed = Math.max(player.speed - player.deceleration, targetSpeed);
            }

            player.x += Math.cos(angle) * player.speed;
            player.y += Math.sin(angle) * player.speed;

            player.x = Math.max(boundary.minX + player.size / 2, Math.min(boundary.maxX - player.size / 2, player.x));
            player.y = Math.max(boundary.minY + player.size / 2, Math.min(boundary.maxY - player.size / 2, player.y));
            player.facingRight = player.targetX > player.x;
        }

        // 生成敵人（沖兒）
        function spawnEnemy() {
            const holeIndex = Math.floor(Math.random() * holes.length);
            const hole = holes[holeIndex];
            const angle = Math.random() * Math.PI * 2;
            const spawnDistance = holeRadius + enemySize / 2;
            const isLarge = Math.random() < 0.10;
            const enemy = {
                x: hole.x + Math.cos(angle) * spawnDistance,
                y: hole.y + Math.sin(angle) * spawnDistance,
                speed: 0,
                maxSpeed: isLarge ? 1.25 : 2.5,
                acceleration: 0.1, // 加速度降低
                delay: 2000, // 延長起跑時間
                targetX: 0,
                targetY: 0,
                size: isLarge ? enemySize * 2 : enemySize,
                holeIndex: holeIndex,
                hp: isLarge ? 2 : 1,
                isLarge: isLarge
            };

            const escapeAngle = Math.random() * Math.PI * 2;
            const escapeDistance = 1000;
            enemy.targetX = enemy.x + Math.cos(escapeAngle) * escapeDistance;
            enemy.targetY = enemy.y + Math.sin(escapeAngle) * escapeDistance;

            enemies.push(enemy);
            return holeIndex;
        }

        // 生成曹昂
        function spawnCaoAng(excludeHoleIndex) {
            let holeIndex;
            do {
                holeIndex = Math.floor(Math.random() * holes.length);
            } while (holeIndex === excludeHoleIndex);

            const hole = holes[holeIndex];
            const angle = Math.random() * Math.PI * 2;
            const spawnDistance = holeRadius + enemySize / 2;
            const caoAng = {
                x: hole.x + Math.cos(angle) * spawnDistance,
                y: hole.y + Math.sin(angle) * spawnDistance,
                speed: 0,
                maxSpeed: 2.5,
                acceleration: 0.1, // 加速度降低
                delay: 2000, // 延長起跑時間
                targetX: 0,
                targetY: 0,
                size: enemySize
            };

            const escapeAngle = Math.random() * Math.PI * 2;
            const escapeDistance = 1000;
            caoAng.targetX = caoAng.x + Math.cos(escapeAngle) * escapeDistance;
            caoAng.targetY = caoAng.y + Math.sin(escapeAngle) * escapeDistance;

            caoAngs.push(caoAng);
        }

        // 生成道具
        function spawnItem() {
            const rand = Math.random();
            let itemType, itemImage;
            if (rand < 0.52) {
                itemType = 'wine';
                itemImage = wineImage;
            } else if (rand < 0.99) {
                itemType = 'fireKill';
                itemImage = fireKillImage;
            } else {
                itemType = 'ancientSword';
                itemImage = ancientSwordImage;
            }

            const item = {
                x: Math.random() * (boundary.maxX - itemSize) + itemSize / 2,
                y: Math.random() * (boundary.maxY - itemSize) + itemSize / 2,
                size: itemSize,
                type: itemType,
                image: itemImage
            };
            items.push(item);
        }

        // 更新敵人（沖兒）位置並添加轉彎邏輯
        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];

                if (enemy.delay > 0) {
                    enemy.delay -= 1000 / 60;
                    continue;
                }

                const dx = enemy.targetX - enemy.x;
                const dy = enemy.targetY - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 1 || enemy.x < boundary.minX || enemy.x > boundary.maxX || enemy.y < boundary.minY || enemy.y > boundary.maxY) {
                    enemies.splice(i, 1);
                    continue;
                }

                const playerDx = player.x - enemy.x;
                const playerDy = player.y - enemy.y;
                const playerDistance = Math.sqrt(playerDx * playerDx + playerDy * playerDy);

                // 若主角靠近，沖兒轉彎
                if (playerDistance < 150) {
                    const currentAngle = Math.atan2(dy, dx);
                    const turnAngle = (Math.random() - 0.5) * 0.3; // 轉彎幅度加大
                    const newAngle = currentAngle + turnAngle;
                    enemy.targetX = enemy.x + Math.cos(newAngle) * 1000;
                    enemy.targetY = enemy.y + Math.sin(newAngle) * 1000;
                }

                // 持續隨機轉彎
                const slightTurn = (Math.random() - 0.5) * 0.05;
                const currentAngle = Math.atan2(dy, dx);
                const newAngle = currentAngle + slightTurn;
                enemy.targetX = enemy.x + Math.cos(newAngle) * 1000;
                enemy.targetY = enemy.y + Math.sin(newAngle) * 1000;

                const angle = Math.atan2(dy, dx);
                enemy.speed = Math.min(enemy.speed + enemy.acceleration, enemy.maxSpeed);
                enemy.x += Math.cos(angle) * enemy.speed;
                enemy.y += Math.sin(angle) * enemy.speed;

                if (playerDistance < (player.size + enemy.size) / 2) {
                    enemy.hp--;
                    if (enemy.hp <= 0) {
                        enemies.splice(i, 1);
                        comboCount++;

                        // 根據 BUFF 狀態播放音效
                        if (ancientSwordDurability > 0) {
                            new Audio(hitSound.src).play();
                            if (fireKillBuff) new Audio(fireMinusTwoSound.src).play();
                            else new Audio(minusTwoSound.src).play();
                        } else if (wineBuff && fireKillBuff) {
                            new Audio(fireMinusTwoSound.src).play();
                            new Audio(hitSound.src).play();
                        } else if (wineBuff) {
                            new Audio(minusTwoSound.src).play();
                            new Audio(slaughterSound.src).play();
                        } else if (fireKillBuff) {
                            new Audio(fireMinusTwoSound.src).play();
                            new Audio(slaughterSound.src).play();
                        } else {
                            new Audio(minusOneSound.src).play();
                        }

                        let baseScore = enemy.isLarge ? 3 : 1;
                        baseScore += (wineBuff ? 1 : 0) + (fireKillBuff ? 1 : 0);
                        let totalScore = ancientSwordDurability > 0 ? baseScore * 2 : baseScore;
                        totalScore += comboCount;
                        score += totalScore;
                        if (wineBuff) wineBuff = false;
                        if (fireKillBuff) fireKillBuff = false;
                        if (ancientSwordDurability > 0) ancientSwordDurability = Math.max(0, ancientSwordDurability - 5);
                        updateBuffDisplay();
                        updateComboDisplay();
                        scoreDisplay.textContent = `分數: ${score}`;
                    }
                }
            }
        }

        // 更新曹昂位置
        function updateCaoAngs() {
            for (let i = caoAngs.length - 1; i >= 0; i--) {
                const caoAng = caoAngs[i];

                if (caoAng.delay > 0) {
                    caoAng.delay -= 1000 / 60;
                    continue;
                }

                const dx = caoAng.targetX - caoAng.x;
                const dy = caoAng.targetY - caoAng.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 1 || caoAng.x < boundary.minX || caoAng.x > boundary.maxX || caoAng.y < boundary.minY || caoAng.y > boundary.maxY) {
                    caoAngs.splice(i, 1);
                    continue;
                }

                const angle = Math.atan2(dy, dx);
                caoAng.speed = Math.min(caoAng.speed + caoAng.acceleration, caoAng.maxSpeed);
                caoAng.x += Math.cos(angle) * caoAng.speed;
                caoAng.y += Math.sin(angle) * caoAng.speed;

                const playerDx = player.x - caoAng.x;
                const playerDy = player.y - caoAng.y;
                const playerDistance = Math.sqrt(playerDx * playerDx + playerDy * playerDy);
                if (playerDistance < (player.size + caoAng.size) / 2) {
                    caoAngs.splice(i, 1);
                    const sound = new Audio(flashSound.src);
                    sound.play();
                    comboCount = 0;
                    if (wineBuff) wineBuff = false;
                    if (fireKillBuff) fireKillBuff = false;
                    if (ancientSwordDurability > 0) ancientSwordDurability = Math.max(0, ancientSwordDurability - 5);
                    updateBuffDisplay();
                    updateComboDisplay();
                }
            }
        }

        // 更新道具
        function updateItems() {
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                const dx = player.x - item.x;
                const dy = player.y - item.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < (player.size + item.size) / 2) {
                    items.splice(i, 1);
                    if (item.type === 'wine') {
                        wineBuff = true;
                        const sound = new Audio(wineSound.src);
                        sound.play();
                    } else if (item.type === 'fireKill') {
                        fireKillBuff = true;
                        const sound = new Audio(fireKillSound.src);
                        sound.play();
                    } else if (item.type === 'ancientSword') {
                        ancientSwordDurability = 100;
                        const sound = new Audio(equipSound.src);
                        sound.play();
                    }
                    updateBuffDisplay();
                }
            }
        }

        // 更新 BUFF 顯示
        function updateBuffDisplay() {
            let buffs = [];
            if (wineBuff) buffs.push('酒');
            if (fireKillBuff) buffs.push('火殺');
            if (ancientSwordDurability > 0) buffs.push(`古錠刀 (${ancientSwordDurability}%)`);
            buffsDisplay.textContent = `BUFF: ${buffs.length > 0 ? buffs.join(', ') : '無'}`;
        }

        // 繪製遊戲畫面
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameActive) {
                for (const hole of holes) {
                    if (holeImage.complete) {
                        ctx.drawImage(holeImage, hole.x - holeRadius, hole.y - holeRadius, holeRadius * 2, holeRadius * 2);
                    } else {
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(hole.x, hole.y, holeRadius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.closePath();
                    }
                }

                for (const item of items) {
                    if (item.image.complete) {
                        ctx.drawImage(item.image, item.x - item.size / 2, item.y - item.size / 2, item.size, item.size);
                    } else {
                        ctx.fillStyle = 'yellow';
                        ctx.fillRect(item.x - item.size / 2, item.y - item.size / 2, item.size, item.size);
                    }
                }

                for (const enemy of enemies) {
                    if (enemyImage.complete) {
                        ctx.drawImage(enemyImage, enemy.x - enemy.size / 2, enemy.y - enemy.size / 2, enemy.size, enemy.size);
                    } else {
                        ctx.fillStyle = 'green';
                        ctx.fillRect(enemy.x - enemy.size / 2, enemy.y - enemy.size / 2, enemy.size, enemy.size);
                    }
                }

                for (const caoAng of caoAngs) {
                    if (caoAngImage.complete) {
                        ctx.drawImage(caoAngImage, caoAng.x - caoAng.size / 2, caoAng.y - caoAng.size / 2, caoAng.size, caoAng.size);
                    } else {
                        ctx.fillStyle = 'purple';
                        ctx.fillRect(caoAng.x - caoAng.size / 2, caoAng.y - caoAng.size / 2, caoAng.size, caoAng.size);
                    }
                }

                if (playerImage.complete) {
                    ctx.save();
                    ctx.translate(player.x, player.y);
                    if (player.facingRight) ctx.scale(-1, 1);
                    ctx.drawImage(playerImage, -player.size / 2, -player.size / 2, player.size, player.size);
                    ctx.restore();
                } else {
                    ctx.fillStyle = 'red';
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                }
            }
        }

        // 遊戲主迴圈
        function gameLoop() {
            if (gameActive) {
                updatePlayer();
                updateEnemies();
                updateCaoAngs();
                updateItems();
                baoAnimation.style.display = 'none';
                swordAnimation.style.display = 'none';
            } else {
                baoAnimation.style.display = 'block';
                swordAnimation.style.display = 'block';
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        // 隨機生成不重疊的洞
        function generateHoles() {
            const centerArea = { minX: 250, maxX: 550, minY: 250, maxY: 550 };
            while (holes.length < 3) {
                const newHole = {
                    x: Math.random() * (centerArea.maxX - centerArea.minX - 2 * holeRadius) + centerArea.minX + holeRadius,
                    y: Math.random() * (centerArea.maxY - centerArea.minY - 2 * holeRadius) + centerArea.minY + holeRadius
                };
                let overlapping = false;
                for (const hole of holes) {
                    const dx = newHole.x - hole.x;
                    const dy = newHole.y - hole.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < holeRadius * 2) {
                        overlapping = true;
                        break;
                    }
                }
                if (!overlapping) holes.push(newHole);
            }
        }

        // 滑鼠移動事件（PC）
        if (!isTouchDevice) {
            canvas.addEventListener('mousemove', (event) => {
                if (!gameActive) return;
                const rect = canvas.getBoundingClientRect();
                player.targetX = Math.max(boundary.minX + player.size / 2, Math.min(boundary.maxX - player.size / 2, event.clientX - rect.left));
                player.targetY = Math.max(boundary.minY + player.size / 2, Math.min(boundary.maxY - player.size / 2, event.clientY - rect.top));
            });
        }

        // 觸控事件（手機）
        if (isTouchDevice) {
            canvas.addEventListener('touchstart', (event) => {
                if (!gameActive) return;
                event.preventDefault();
                const touch = event.touches[0];
                const rect = canvas.getBoundingClientRect();
                player.targetX = Math.max(boundary.minX + player.size / 2, Math.min(boundary.maxX - player.size / 2, touch.clientX - rect.left));
                player.targetY = Math.max(boundary.minY + player.size / 2, Math.min(boundary.maxY - player.size / 2, touch.clientY - rect.top));
                player.moving = true;
            });

            canvas.addEventListener('touchmove', (event) => {
                if (!gameActive) return;
                event.preventDefault();
                const touch = event.touches[0];
                const rect = canvas.getBoundingClientRect();
                player.targetX = Math.max(boundary.minX + player.size / 2, Math.min(boundary.maxX - player.size / 2, touch.clientX - rect.left));
                player.targetY = Math.max(boundary.minY + player.size / 2, Math.min(boundary.maxY - player.size / 2, touch.clientY - rect.top));
            });
        }

        // 開始遊戲
        function startGame() {
            menu.style.display = 'none';
            canvas.style.display = 'block';
            scoreDisplay.style.display = 'inline-block';
            buffsDisplay.style.display = 'inline-block';
            timerDisplay.style.display = 'inline-block';
            comboDisplay.style.display = 'inline-block';

            score = 0;
            wineBuff = false;
            fireKillBuff = false;
            ancientSwordDurability = 0;
            comboCount = 0;
            timeLeft = 60;
            gameActive = true;
            enemies.length = 0;
            caoAngs.length = 0;
            items.length = 0;
            holes.length = 0;
            generateHoles();
            scoreDisplay.textContent = `分數: ${score}`;
            updateBuffDisplay();
            updateComboDisplay();
            timerDisplay.textContent = `剩餘時間: ${Math.ceil(timeLeft)}`;

            bgm.play();

            spawnInterval = setInterval(() => {
                const enemyHoleIndex = spawnEnemy();
                if (Math.random() < 0.30) spawnCaoAng(enemyHoleIndex);
                if (Math.random() < 0.20) spawnItem();

                timeLeft -= 0.5;
                timerDisplay.textContent = `剩餘時間: ${Math.ceil(timeLeft)}`;
                if (timeLeft <= 0) endGame();
            }, 500);
        }

        // 結束遊戲
        function endGame() {
            gameActive = false;
            clearInterval(spawnInterval);
            canvas.style.display = 'none';
            scoreDisplay.style.display = 'none';
            buffsDisplay.style.display = 'none';
            timerDisplay.style.display = 'none';
            comboDisplay.style.display = 'none';
            nameInput.style.display = 'block';
            finalScoreDisplay.textContent = score;
            bgm.pause();
            bgm.currentTime = 0;
        }

        // 儲存分數到排行榜
        function saveScore() {
            const name = document.getElementById('playerName').value.trim();
            if (!name) return alert('請輸入名稱！');

            let leaderboardData = JSON.parse(localStorage.getItem('leaderboard') || '[]');
            leaderboardData.push({ name, score });
            leaderboardData.sort((a, b) => b.score - a.score);
            leaderboardData = leaderboardData.slice(0, 10);
            localStorage.setItem('leaderboard', JSON.stringify(leaderboardData));

            nameInput.style.display = 'none';
            showLeaderboard();
        }

        // 顯示排行榜
        function showLeaderboard() {
            menu.style.display = 'none';
            leaderboard.style.display = 'block';
            const leaderboardData = JSON.parse(localStorage.getItem('leaderboard') || '[]');
            leaderboardList.innerHTML = leaderboardData.length > 0
                ? leaderboardData.map((entry, index) => `${index + 1}. ${entry.name}: ${entry.score}`).join('<br>')
                : '尚無紀錄';
            baoAnimation.style.display = 'block';
            swordAnimation.style.display = 'block';
        }

        // 返回主選單
        function backToMenu() {
            leaderboard.style.display = 'none';
            menu.style.display = 'block';
            baoAnimation.style.display = 'block';
            swordAnimation.style.display = 'block';
        }

        // 初始化並啟動遊戲主迴圈
        gameLoop();
    </script>
</body>
</html>
