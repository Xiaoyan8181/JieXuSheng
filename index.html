<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>早起的寶兒有沖砍</title>
    <style>
        canvas {
            border: 1px solid black;
            float: left;
            display: none;
        }
        #score, #buffs, #timer {
            font-size: 24px;
            margin-left: 20px;
            display: inline-block;
            display: none;
        }
        #combo {
            font-size: 24px;
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            white-space: pre-line;
            display: none;
        }
        #title {
            text-align: center;
            font-size: 36px;
            margin-top: 10px;
        }
        #menu {
            text-align: center;
            margin-top: 20px;
            position: relative;
            width: 800px;
            height: 800px;
            margin-left: auto;
            margin-right: auto;
        }
        #menu button {
            font-size: 20px;
            margin: 10px 0;
            padding: 10px 20px;
            display: block;
            width: 200px;
            margin-left: auto;
            margin-right: auto;
        }
        #leaderboard, #nameInput, #instructions {
            display: none;
            text-align: center;
            margin-top: 20px;
        }
        #instructions img {
            display: block;
            margin: 10px auto;
            width: 80px;
            height: 80px;
        }
        #instructions p {
            font-size: 18px;
            margin: 5px 0;
        }
        #instructions .hp {
            font-size: 16px;
            margin-top: -5px;
        }
        #instructions .category {
            font-size: 24px;
            margin: 20px 0;
        }
        #instructions .item-category {
            font-size: 24px;
            margin: 20px 0;
            animation: scalePulse 3s ease-in-out infinite; /* 道具類放大縮小效果 */
        }
        #baoAnimation {
            position: fixed;
            bottom: 10px;
            right: 10px;
            width: 200px;
            height: 200px;
            z-index: 10;
        }
        #swordAnimation {
            position: fixed;
            bottom: 10px;
            left: 10px;
            width: 200px;
            height: 200px;
            animation: rotate 2s linear infinite;
        }
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        @keyframes scalePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
    </style>
</head>
<body>
    <div id="title">早起的寶兒有沖砍</div>
    <canvas id="gameCanvas" width="800" height="800"></canvas>
    <div id="score">分數: 0</div>
    <div id="buffs">BUFF: 無</div>
    <div id="timer">剩餘時間: 60</div>
    <div id="combo">COMBO: 0</div>

    <div id="menu">
        <button onclick="startGame()">開始遊戲</button>
        <button onclick="showLeaderboard()">本機排行榜</button>
        <button onclick="showInstructions()">遊戲說明</button>
        <button onclick="window.close()">離開</button>
    </div>
    <div id="leaderboard">
        <h2>排行榜</h2>
        <div id="leaderboardList"></div>
        <button onclick="backToMenu()">返回</button>
    </div>
    <div id="nameInput">
        <h2>遊戲結束！你的分數: <span id="finalScore"></span></h2>
        <input type="text" id="playerName" placeholder="輸入你的名稱" maxlength="20">
        <button onclick="saveScore()">提交</button>
    </div>
    <div id="instructions">
        <h2>遊戲說明</h2>
        <p class="category">~角色類~</p>
        <img src="./images/大寶.gif" alt="大寶">
        <p>這是你! 你可以操控他追擊沖兒獲得積分!</p>
        <img src="./images/沖兒.png" alt="沖兒">
        <p>經典沖兒! 擊殺可獲得1積分!</p>
        <p class="hp">HP2</p>
        <img src="./images/沖兒.png" alt="大沖兒" style="width: 120px; height: 120px;">
        <p>大沖兒: 較大的沖兒! 擊殺可獲得3積分!</p>
        <p class="hp">HP5</p>
        <img src="./images/曹昂.png" alt="曹昂">
        <p>昂寶! 若想擊殺會被閃!</p>
        <p class="hp">HP4</p>
        <img src="./images/小虎.png" alt="小虎">
        <p>小虎! 千萬別碰到她! 不然就要擊殺她才能觸碰其他人! 擊殺可獲得1積分!</p>
        <p class="hp">HP10</p>
        <img src="./images/謀諸葛.png" alt="謀諸葛">
        <p>謀諸葛! 碰到會扣減積分!</p>
        <p class="hp">HP50</p>
        <p>COMBO數會加分 但昂寶和謀諸葛會斷COMBO!</p>
        <p class="item-category">~道具類~</p>
        <img src="./images/酒.png" alt="酒">
        <p>酒: 讓你下一次的傷害+1! 並且擊殺的積分+1!</p>
        <img src="./images/火殺.png" alt="火殺">
        <p>火殺: 獲得火焰附魔2次!(可疊加) 讓你傷害+1! 並且擊殺的積分+1!</p>
        <img src="./images/古錠刀.png" alt="古錠刀">
        <p>古錠刀: 獲得古錠刀! 讓你傷害翻倍! 並且擊殺的積分翻倍! 每次使用耐久-5%</p>
        <button onclick="backToMenu()">返回</button>
    </div>

    <img id="baoAnimation" src="./images/大寶.gif" alt="大寶">
    <img id="swordAnimation" src="./images/古錠刀.png" alt="古錠刀">

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const buffsDisplay = document.getElementById('buffs');
        const timerDisplay = document.getElementById('timer');
        const comboDisplay = document.getElementById('combo');
        const menu = document.getElementById('menu');
        const leaderboard = document.getElementById('leaderboard');
        const leaderboardList = document.getElementById('leaderboardList');
        const nameInput = document.getElementById('nameInput');
        const instructions = document.getElementById('instructions');
        const finalScoreDisplay = document.getElementById('finalScore');
        const baoAnimation = document.getElementById('baoAnimation');
        const swordAnimation = document.getElementById('swordAnimation');

        // 載入圖片和音效
        const playerImage = new Image(); playerImage.src = './images/大寶.gif';
        const enemyImage = new Image(); enemyImage.src = './images/沖兒.png';
        const caoAngImage = new Image(); caoAngImage.src = './images/曹昂.png';
        const tigerImage = new Image(); tigerImage.src = './images/小虎.png';
        const zhugeImage = new Image(); zhugeImage.src = './images/謀諸葛.png';
        const wineImage = new Image(); wineImage.src = './images/酒.png';
        const fireKillImage = new Image(); fireKillImage.src = './images/火殺.png';
        const ancientSwordImage = new Image(); ancientSwordImage.src = './images/古錠刀.png';
        const holeImage = new Image(); holeImage.src = './images/Hole.png';
        const hitSound = new Audio('./audio/萬軍取首.mp3');
        const slaughterSound = new Audio('./audio/癲狂屠戮.mp3');
        const flashSound = new Audio('./audio/閃.mp3');
        const wineSound = new Audio('./audio/酒.mp3');
        const fireKillSound = new Audio('./audio/火殺.mp3');
        const equipSound = new Audio('./audio/equip.mp3');
        const tigerSound = new Audio('./audio/先殺我吧.mp3');
        const zhugeSound = new Audio('./audio/知汝欲行此技.mp3');
        const bgm = new Audio('./audio/BGM.mp3');
        const minusOneSound = new Audio('./audio/-1.mp3');
        const minusTwoSound = new Audio('./audio/-2.mp3');
        const fireMinusTwoSound = new Audio('./audio/火-2.mp3');
        bgm.loop = true;

        // 主角物件
        const player = {
            x: 400, y: 400, speed: 0, maxSpeed: 8, acceleration: 0.1, deceleration: 0.1,
            targetX: 400, targetY: 400, size: 80, moving: false, facingRight: false,
            collisionCooldown: 0
        };

        // 邊界範圍
        const boundary = { minX: 0, minY: 0, maxX: canvas.width, maxY: canvas.height };

        // 分數、BUFF 和 COMBO 狀態
        let score = 0, wineBuff = false, fireKillBuff = 0, ancientSwordDurability = 0,
            comboCount = 0, timeLeft = 60, gameActive = false, spawnInterval,
            boundTiger = null;

        // 檢測是否為觸控裝置
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

        // 洞、敵人和道具陣列
        const holes = [], holeRadius = 30;
        const enemies = [], caoAngs = [], tigers = [], zhuges = [], enemySize = 45;
        const items = [], itemSize = 45;

        // 計算攻擊力
        function calculateAttack() {
            let attack = 2;
            if (wineBuff) attack += 1;
            if (fireKillBuff > 0) attack += 1;
            if (ancientSwordDurability > 0) attack *= 2;
            return attack;
        }

        // 更新 COMBO 顯示
        function updateComboDisplay() {
            let comboText = `COMBO: ${comboCount}\n`;
            if (comboCount === 1) comboText += "一破 臥龍出山";
            else if (comboCount === 2) comboText += "雙連 一戰成名";
            else if (comboCount === 3) comboText += "三連 舉世皆驚";
            else if (comboCount === 4) comboText += "四連 天下無敵";
            else if (comboCount >= 5) comboText += "誅天滅地";
            else comboText += "";
            comboDisplay.textContent = comboText;
        }

        // 更新主角位置
        function updatePlayer() {
            const dx = player.targetX - player.x;
            const dy = player.targetY - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < 1) {
                player.x = player.targetX;
                player.y = player.targetY;
                player.speed = 0;
                player.moving = false;
                return;
            }

            const angle = Math.atan2(dy, dx);
            const targetSpeed = distance < 50 ? distance / 10 : player.maxSpeed;

            if (player.speed < targetSpeed) {
                player.speed = Math.min(player.speed + player.acceleration, targetSpeed);
            } else {
                player.speed = Math.max(player.speed - player.deceleration, targetSpeed);
            }

            player.x += Math.cos(angle) * player.speed;
            player.y += Math.sin(angle) * player.speed;

            player.x = Math.max(boundary.minX + player.size / 2, Math.min(boundary.maxX - player.size / 2, player.x));
            player.y = Math.max(boundary.minY + player.size / 2, Math.min(boundary.maxY - player.size / 2, player.y));
            player.facingRight = player.targetX > player.x;

            if (player.collisionCooldown > 0) player.collisionCooldown -= 1000 / 60;
        }

        // 生成敵人（沖兒）
        function spawnEnemy() {
            const holeIndex = Math.floor(Math.random() * holes.length);
            const hole = holes[holeIndex];
            const angle = Math.random() * Math.PI * 2;
            const spawnDistance = holeRadius + enemySize / 2;
            const isLarge = Math.random() < 0.10;
            const enemy = {
                x: hole.x + Math.cos(angle) * spawnDistance,
                y: hole.y + Math.sin(angle) * spawnDistance,
                speed: 0,
                maxSpeed: isLarge ? 1.25 : 2.5,
                acceleration: 0.1,
                delay: 2000,
                targetX: 0,
                targetY: 0,
                size: isLarge ? enemySize * 2 : enemySize,
                holeIndex: holeIndex,
                hp: isLarge ? 5 : 2,
                maxHp: isLarge ? 5 : 2,
                isLarge: isLarge,
                facingRight: false // 新增方向屬性
            };

            const escapeAngle = Math.random() * Math.PI * 2;
            const escapeDistance = 1000;
            enemy.targetX = enemy.x + Math.cos(escapeAngle) * escapeDistance;
            enemy.targetY = enemy.y + Math.sin(escapeAngle) * escapeDistance;

            enemies.push(enemy);
            return holeIndex;
        }

        // 生成其他角色（曹昂、小虎、謀諸葛）
        function spawnOtherCharacter(excludeHoleIndex) {
            let holeIndex;
            do {
                holeIndex = Math.floor(Math.random() * holes.length);
            } while (holeIndex === excludeHoleIndex);

            const hole = holes[holeIndex];
            const angle = Math.random() * Math.PI * 2;
            const spawnDistance = holeRadius + enemySize / 2;

            const rand = Math.random();
            if (rand < 0.95) {
                const caoAng = {
                    x: hole.x + Math.cos(angle) * spawnDistance,
                    y: hole.y + Math.sin(angle) * spawnDistance,
                    speed: 0,
                    maxSpeed: 2.5,
                    acceleration: 0.1,
                    delay: 2000,
                    targetX: 0,
                    targetY: 0,
                    size: enemySize,
                    hp: 4,
                    maxHp: 4,
                    type: 'caoAng',
                    facingRight: false
                };
                const escapeAngle = Math.random() * Math.PI * 2;
                const escapeDistance = 1000;
                caoAng.targetX = caoAng.x + Math.cos(escapeAngle) * escapeDistance;
                caoAng.targetY = caoAng.y + Math.sin(escapeAngle) * escapeDistance;
                caoAngs.push(caoAng);
            } else if (rand < 0.98) {
                const tiger = {
                    x: hole.x + Math.cos(angle) * spawnDistance,
                    y: hole.y + Math.sin(angle) * spawnDistance,
                    speed: 0,
                    maxSpeed: 1,
                    acceleration: 0.1,
                    delay: 2000,
                    targetX: 0,
                    targetY: 0,
                    size: enemySize,
                    hp: 10,
                    maxHp: 10,
                    type: 'tiger',
                    wandering: false,
                    facingRight: false
                };
                const escapeAngle = Math.random() * Math.PI * 2;
                const escapeDistance = 1000;
                tiger.targetX = tiger.x + Math.cos(escapeAngle) * escapeDistance;
                tiger.targetY = tiger.y + Math.sin(escapeAngle) * escapeDistance;
                tigers.push(tiger);
            } else {
                const zhuge = {
                    x: hole.x + Math.cos(angle) * spawnDistance,
                    y: hole.y + Math.sin(angle) * spawnDistance,
                    speed: 0,
                    maxSpeed: 1,
                    acceleration: 0.1,
                    delay: 2000,
                    targetX: 0,
                    targetY: 0,
                    size: enemySize,
                    hp: 50,
                    maxHp: 50,
                    type: 'zhuge',
                    facingRight: false
                };
                const escapeAngle = Math.random() * Math.PI * 2;
                const escapeDistance = 1000;
                zhuge.targetX = zhuge.x + Math.cos(escapeAngle) * escapeDistance;
                zhuge.targetY = zhuge.y + Math.sin(escapeAngle) * escapeDistance;
                zhuges.push(zhuge);
            }
        }

        // 生成道具
        function spawnItem() {
            const rand = Math.random();
            let itemType, itemImage;
            if (rand < 0.52) {
                itemType = 'wine';
                itemImage = wineImage;
            } else if (rand < 0.99) {
                itemType = 'fireKill';
                itemImage = fireKillImage;
            } else {
                itemType = 'ancientSword';
                itemImage = ancientSwordImage;
            }

            const item = {
                x: Math.random() * (boundary.maxX - itemSize) + itemSize / 2,
                y: Math.random() * (boundary.maxY - itemSize) + itemSize / 2,
                size: itemSize,
                type: itemType,
                image: itemImage,
                rotation: 0,
                scale: 1 // 新增縮放屬性
            };
            items.push(item);
        }

        // 更新敵人（沖兒）位置並添加轉彎邏輯
        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];

                if (enemy.delay > 0) {
                    enemy.delay -= 1000 / 60;
                    continue;
                }

                const dx = enemy.targetX - enemy.x;
                const dy = enemy.targetY - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 1 || enemy.x < boundary.minX || enemy.x > boundary.maxX || enemy.y < boundary.minY || enemy.y > boundary.maxY) {
                    enemies.splice(i, 1);
                    continue;
                }

                const playerDx = player.x - enemy.x;
                const playerDy = player.y - enemy.y;
                const playerDistance = Math.sqrt(playerDx * playerDx + playerDy * playerDy);

                if (playerDistance < 150) {
                    const currentAngle = Math.atan2(dy, dx);
                    const turnAngle = (Math.random() - 0.5) * 0.3;
                    const newAngle = currentAngle + turnAngle;
                    enemy.targetX = enemy.x + Math.cos(newAngle) * 1000;
                    enemy.targetY = enemy.y + Math.sin(newAngle) * 1000;
                }

                const slightTurn = (Math.random() - 0.5) * 0.05;
                const currentAngle = Math.atan2(dy, dx);
                const newAngle = currentAngle + slightTurn;
                enemy.targetX = enemy.x + Math.cos(newAngle) * 1000;
                enemy.targetY = enemy.y + Math.sin(newAngle) * 1000;

                const angle = Math.atan2(dy, dx);
                enemy.speed = Math.min(enemy.speed + enemy.acceleration, enemy.maxSpeed);
                enemy.x += Math.cos(angle) * enemy.speed;
                enemy.y += Math.sin(angle) * enemy.speed;
                enemy.facingRight = enemy.targetX > enemy.x;

                if (playerDistance < (player.size + enemy.size) / 2 && player.collisionCooldown <= 0 && (!boundTiger || boundTiger.hp <= 0)) {
                    enemy.hp -= calculateAttack();
                    player.collisionCooldown = 500;
                    if (enemy.hp <= 0) {
                        enemies.splice(i, 1);
                        comboCount++;

                        if (ancientSwordDurability > 0) {
                            new Audio(hitSound.src).play();
                            if (fireKillBuff > 0) new Audio(fireMinusTwoSound.src).play();
                            else new Audio(minusTwoSound.src).play();
                        } else if (wineBuff && fireKillBuff > 0) {
                            new Audio(fireMinusTwoSound.src).play();
                            new Audio(hitSound.src).play();
                        } else if (wineBuff) {
                            new Audio(minusTwoSound.src).play();
                            new Audio(slaughterSound.src).play();
                        } else if (fireKillBuff > 0) {
                            new Audio(fireMinusTwoSound.src).play();
                            new Audio(slaughterSound.src).play();
                        } else {
                            new Audio(minusOneSound.src).play();
                        }

                        let baseScore = enemy.isLarge ? 3 : 1;
                        baseScore += (wineBuff ? 1 : 0) + (fireKillBuff > 0 ? 1 : 0);
                        let totalScore = ancientSwordDurability > 0 ? baseScore * 2 : baseScore;
                        totalScore += comboCount;
                        score += totalScore;
                        if (wineBuff) wineBuff = false;
                        if (fireKillBuff > 0) fireKillBuff = Math.max(0, fireKillBuff - 1);
                        if (ancientSwordDurability > 0) ancientSwordDurability = Math.max(0, ancientSwordDurability - 5);
                        updateBuffDisplay();
                        updateComboDisplay();
                        scoreDisplay.textContent = `分數: ${score}`;
                    }
                }
            }
        }

        // 更新曹昂位置
        function updateCaoAngs() {
            for (let i = caoAngs.length - 1; i >= 0; i--) {
                const caoAng = caoAngs[i];

                if (caoAng.delay > 0) {
                    caoAng.delay -= 1000 / 60;
                    continue;
                }

                const dx = caoAng.targetX - caoAng.x;
                const dy = caoAng.targetY - caoAng.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 1 || caoAng.x < boundary.minX || caoAng.x > boundary.maxX || caoAng.y < boundary.minY || caoAng.y > boundary.maxY) {
                    caoAngs.splice(i, 1);
                    continue;
                }

                const angle = Math.atan2(dy, dx);
                caoAng.speed = Math.min(caoAng.speed + caoAng.acceleration, caoAng.maxSpeed);
                caoAng.x += Math.cos(angle) * caoAng.speed;
                caoAng.y += Math.sin(angle) * caoAng.speed;
                caoAng.facingRight = caoAng.targetX > caoAng.x;

                const playerDx = player.x - caoAng.x;
                const playerDy = player.y - caoAng.y;
                const playerDistance = Math.sqrt(playerDx * playerDx + playerDy * playerDy);
                if (playerDistance < (player.size + caoAng.size) / 2 && player.collisionCooldown <= 0 && (!boundTiger || boundTiger.hp <= 0)) {
                    caoAng.hp -= calculateAttack();
                    player.collisionCooldown = 500;
                    if (caoAng.hp <= 0) {
                        caoAngs.splice(i, 1);
                        new Audio(flashSound.src).play();
                        comboCount = 0;
                        if (wineBuff) wineBuff = false;
                        if (fireKillBuff > 0) fireKillBuff = Math.max(0, fireKillBuff - 1);
                        if (ancientSwordDurability > 0) ancientSwordDurability = Math.max(0, ancientSwordDurability - 5);
                        updateBuffDisplay();
                        updateComboDisplay();
                    }
                }
            }
        }

        // 更新小虎位置
        function updateTigers() {
            for (let i = tigers.length - 1; i >= 0; i--) {
                const tiger = tigers[i];

                if (tiger.delay > 0) {
                    tiger.delay -= 1000 / 60;
                    continue;
                }

                const dx = tiger.targetX - tiger.x;
                const dy = tiger.targetY - tiger.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 1 || tiger.x < boundary.minX || tiger.x > boundary.maxX || tiger.y < boundary.minY || tiger.y > boundary.maxY) {
                    if (!tiger.wandering) {
                        tiger.targetX = Math.random() * (boundary.maxX - tiger.size) + tiger.size / 2;
                        tiger.targetY = Math.random() * (boundary.maxY - tiger.size) + tiger.size / 2;
                        tiger.wandering = true;
                    }
                }

                const playerDx = player.x - tiger.x;
                const playerDy = player.y - tiger.y;
                const playerDistance = Math.sqrt(playerDx * playerDx + playerDy * playerDy);

                if (playerDistance < (player.size + tiger.size) / 2 && player.collisionCooldown <= 0) {
                    if (!boundTiger) {
                        boundTiger = tiger;
                        new Audio(tigerSound.src).play();
                    }

                    if (boundTiger === tiger) {
                        tiger.hp -= calculateAttack();
                        player.collisionCooldown = 500;
                        new Audio(tigerSound.src).play();
                        if (!tiger.wandering) {
                            tiger.targetX = Math.random() * (boundary.maxX - tiger.size) + tiger.size / 2;
                            tiger.targetY = Math.random() * (boundary.maxY - tiger.size) + tiger.size / 2;
                            tiger.wandering = true;
                        }

                        if (tiger.hp <= 0) {
                            tigers.splice(i, 1);
                            if (boundTiger === tiger) boundTiger = null;
                            comboCount++;
                            let baseScore = 1;
                            baseScore += (wineBuff ? 1 : 0) + (fireKillBuff > 0 ? 1 : 0);
                            let totalScore = ancientSwordDurability > 0 ? baseScore * 2 : baseScore;
                            totalScore += comboCount;
                            score += totalScore;

                            if (ancientSwordDurability > 0) {
                                new Audio(hitSound.src).play();
                                if (fireKillBuff > 0) new Audio(fireMinusTwoSound.src).play();
                                else new Audio(minusTwoSound.src).play();
                            } else if (wineBuff && fireKillBuff > 0) {
                                new Audio(fireMinusTwoSound.src).play();
                                new Audio(hitSound.src).play();
                            } else if (wineBuff) {
                                new Audio(minusTwoSound.src).play();
                                new Audio(slaughterSound.src).play();
                            } else if (fireKillBuff > 0) {
                                new Audio(fireMinusTwoSound.src).play();
                                new Audio(slaughterSound.src).play();
                            } else {
                                new Audio(minusOneSound.src).play();
                            }
                        }
                        if (wineBuff) wineBuff = false;
                        if (fireKillBuff > 0) fireKillBuff = Math.max(0, fireKillBuff - 1);
                        if (ancientSwordDurability > 0) ancientSwordDurability = Math.max(0, ancientSwordDurability - 5);
                        updateBuffDisplay();
                        updateComboDisplay();
                        scoreDisplay.textContent = `分數: ${score}`;
                    }
                }

                const angle = Math.atan2(dy, dx);
                tiger.speed = Math.min(tiger.speed + tiger.acceleration, tiger.maxSpeed);
                tiger.x += Math.cos(angle) * tiger.speed;
                tiger.y += Math.sin(angle) * tiger.speed;
                tiger.facingRight = tiger.targetX > tiger.x;
            }
        }

        // 更新謀諸葛位置
        function updateZhuges() {
            for (let i = zhuges.length - 1; i >= 0; i--) {
                const zhuge = zhuges[i];

                if (zhuge.delay > 0) {
                    zhuge.delay -= 1000 / 60;
                    continue;
                }

                const dx = zhuge.targetX - zhuge.x;
                const dy = zhuge.targetY - zhuge.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 1 || zhuge.x < boundary.minX || zhuge.x > boundary.maxX || zhuge.y < boundary.minY || zhuge.y > boundary.maxY) {
                    zhuges.splice(i, 1);
                    continue;
                }

                const angle = Math.atan2(dy, dx);
                zhuge.speed = Math.min(zhuge.speed + zhuge.acceleration, zhuge.maxSpeed);
                zhuge.x += Math.cos(angle) * zhuge.speed;
                zhuge.y += Math.sin(angle) * zhuge.speed;
                zhuge.facingRight = zhuge.targetX > zhuge.x;

                const playerDx = player.x - zhuge.x;
                const playerDy = player.y - zhuge.y;
                const playerDistance = Math.sqrt(playerDx * playerDx + playerDy * playerDy);
                if (playerDistance < (player.size + zhuge.size) / 2 && player.collisionCooldown <= 0 && (!boundTiger || boundTiger.hp <= 0)) {
                    zhuges.splice(i, 1);
                    player.collisionCooldown = 500;
                    new Audio(zhugeSound.src).play();
                    comboCount = 0;
                    score = Math.max(0, score - 5);
                    updateComboDisplay();
                    scoreDisplay.textContent = `分數: ${score}`;
                }
            }
        }

        // 更新道具
        function updateItems() {
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                const dx = player.x - item.x;
                const dy = player.y - item.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                item.rotation += 0.05;
                item.scale = 1 + 0.1 * Math.sin(Date.now() * 0.001); // 緩慢放大縮小效果

                if (distance < (player.size + item.size * item.scale) / 2) {
                    items.splice(i, 1);
                    if (item.type === 'wine') {
                        wineBuff = true;
                        new Audio(wineSound.src).play();
                    } else if (item.type === 'fireKill') {
                        fireKillBuff += 2;
                        new Audio(fireKillSound.src).play();
                    } else if (item.type === 'ancientSword') {
                        ancientSwordDurability = 100;
                        new Audio(equipSound.src).play();
                    }
                    updateBuffDisplay();
                }
            }
        }

        // 更新 BUFF 顯示
        function updateBuffDisplay() {
            let buffs = [];
            if (wineBuff) buffs.push('酒');
            if (fireKillBuff > 0) buffs.push(`火殺 (${fireKillBuff} 次)`);
            if (ancientSwordDurability > 0) buffs.push(`古錠刀 (${ancientSwordDurability}%)`);
            buffsDisplay.innerHTML = buffs.length > 0 ? `BUFF:<br>${buffs.join('<br>')}` : 'BUFF: 無';
        }

        // 繪製血條
        function drawHealthBar(x, y, size, hp, maxHp) {
            const barWidth = size;
            const barHeight = 5;
            const healthRatio = hp / maxHp;
            const healthWidth = barWidth * healthRatio;

            ctx.fillStyle = 'gray';
            ctx.fillRect(x - barWidth / 2, y + size / 2 + 5, barWidth, barHeight);

            ctx.fillStyle = healthRatio > 0.5 ? 'green' : healthRatio > 0.2 ? 'yellow' : 'red';
            ctx.fillRect(x - barWidth / 2, y + size / 2 + 5, healthWidth, barHeight);
        }

        // 繪製遊戲畫面
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameActive) {
                for (const hole of holes) {
                    if (holeImage.complete) {
                        ctx.drawImage(holeImage, hole.x - holeRadius, hole.y - holeRadius, holeRadius * 2, holeRadius * 2);
                    } else {
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(hole.x, hole.y, holeRadius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.closePath();
                    }
                }

                for (const item of items) {
                    if (item.image.complete) {
                        ctx.save();
                        ctx.translate(item.x, item.y);
                        ctx.rotate(item.rotation);
                        ctx.scale(item.scale, item.scale); // 應用縮放
                        ctx.drawImage(item.image, -item.size / 2, -item.size / 2, item.size, item.size);
                        ctx.restore();
                    } else {
                        ctx.fillStyle = 'yellow';
                        ctx.fillRect(item.x - item.size / 2, item.y - item.size / 2, item.size, item.size);
                    }
                }

                for (const enemy of enemies) {
                    if (enemyImage.complete) {
                        ctx.save();
                        ctx.translate(enemy.x, enemy.y);
                        if (enemy.facingRight) ctx.scale(-1, 1); // 左右翻轉
                        ctx.drawImage(enemyImage, -enemy.size / 2, -enemy.size / 2, enemy.size, enemy.size);
                        ctx.restore();
                    } else {
                        ctx.fillStyle = 'green';
                        ctx.fillRect(enemy.x - enemy.size / 2, enemy.y - enemy.size / 2, enemy.size, enemy.size);
                    }
                    drawHealthBar(enemy.x, enemy.y, enemy.size, enemy.hp, enemy.maxHp);
                }

                for (const caoAng of caoAngs) {
                    if (caoAngImage.complete) {
                        ctx.save();
                        ctx.translate(caoAng.x, caoAng.y);
                        if (caoAng.facingRight) ctx.scale(-1, 1);
                        ctx.drawImage(caoAngImage, -caoAng.size / 2, -caoAng.size / 2, caoAng.size, caoAng.size);
                        ctx.restore();
                    } else {
                        ctx.fillStyle = 'purple';
                        ctx.fillRect(caoAng.x - caoAng.size / 2, caoAng.y - caoAng.size / 2, caoAng.size, caoAng.size);
                    }
                    drawHealthBar(caoAng.x, caoAng.y, caoAng.size, caoAng.hp, caoAng.maxHp);
                }

                for (const tiger of tigers) {
                    if (tigerImage.complete) {
                        ctx.save();
                        ctx.translate(tiger.x, tiger.y);
                        if (tiger.facingRight) ctx.scale(-1, 1);
                        ctx.drawImage(tigerImage, -tiger.size / 2, -tiger.size / 2, tiger.size, tiger.size);
                        ctx.restore();
                    } else {
                        ctx.fillStyle = 'orange';
                        ctx.fillRect(tiger.x - tiger.size / 2, tiger.y - tiger.size / 2, tiger.size, tiger.size);
                    }
                    drawHealthBar(tiger.x, tiger.y, tiger.size, tiger.hp, tiger.maxHp);
                }

                for (const zhuge of zhuges) {
                    if (zhugeImage.complete) {
                        ctx.save();
                        ctx.translate(zhuge.x, zhuge.y);
                        if (zhuge.facingRight) ctx.scale(-1, 1);
                        ctx.drawImage(zhugeImage, -zhuge.size / 2, -zhuge.size / 2, zhuge.size, zhuge.size);
                        ctx.restore();
                    } else {
                        ctx.fillStyle = 'blue';
                        ctx.fillRect(zhuge.x - zhuge.size / 2, zhuge.y - zhuge.size / 2, zhuge.size, zhuge.size);
                    }
                    drawHealthBar(zhuge.x, zhuge.y, zhuge.size, zhuge.hp, zhuge.maxHp);
                }

                if (playerImage.complete) {
                    ctx.save();
                    ctx.translate(player.x, player.y);
                    if (player.facingRight) ctx.scale(-1, 1);
                    ctx.drawImage(playerImage, -player.size / 2, -player.size / 2, player.size, player.size);
                    ctx.restore();
                } else {
                    ctx.fillStyle = 'red';
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                }
            }
        }

        // 遊戲主迴圈
        function gameLoop() {
            if (gameActive) {
                updatePlayer();
                updateEnemies();
                updateCaoAngs();
                updateTigers();
                updateZhuges();
                updateItems();
                baoAnimation.style.display = 'none';
                swordAnimation.style.display = 'none';
            } else {
                baoAnimation.style.display = 'block';
                swordAnimation.style.display = 'block';
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        // 隨機生成不重疊的洞
        function generateHoles() {
            const centerArea = { minX: 250, maxX: 550, minY: 250, maxY: 550 };
            while (holes.length < 3) {
                const newHole = {
                    x: Math.random() * (centerArea.maxX - centerArea.minX - 2 * holeRadius) + centerArea.minX + holeRadius,
                    y: Math.random() * (centerArea.maxY - centerArea.minY - 2 * holeRadius) + centerArea.minY + holeRadius
                };
                let overlapping = false;
                for (const hole of holes) {
                    const dx = newHole.x - hole.x;
                    const dy = newHole.y - hole.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < holeRadius * 2) {
                        overlapping = true;
                        break;
                    }
                }
                if (!overlapping) holes.push(newHole);
            }
        }

        // 滑鼠移動事件（PC）
        if (!isTouchDevice) {
            canvas.addEventListener('mousemove', (event) => {
                if (!gameActive) return;
                const rect = canvas.getBoundingClientRect();
                player.targetX = Math.max(boundary.minX + player.size / 2, Math.min(boundary.maxX - player.size / 2, event.clientX - rect.left));
                player.targetY = Math.max(boundary.minY + player.size / 2, Math.min(boundary.maxY - player.size / 2, event.clientY - rect.top));
            });
        }

        // 觸控事件（手機）
        if (isTouchDevice) {
            canvas.addEventListener('touchstart', (event) => {
                if (!gameActive) return;
                event.preventDefault();
                const touch = event.touches[0];
                const rect = canvas.getBoundingClientRect();
                player.targetX = Math.max(boundary.minX + player.size / 2, Math.min(boundary.maxX - player.size / 2, touch.clientX - rect.left));
                player.targetY = Math.max(boundary.minY + player.size / 2, Math.min(boundary.maxY - player.size / 2, touch.clientY - rect.top));
                player.moving = true;
            });

            canvas.addEventListener('touchmove', (event) => {
                if (!gameActive) return;
                event.preventDefault();
                const touch = event.touches[0];
                const rect = canvas.getBoundingClientRect();
                player.targetX = Math.max(boundary.minX + player.size / 2, Math.min(boundary.maxX - player.size / 2, touch.clientX - rect.left));
                player.targetY = Math.max(boundary.minY + player.size / 2, Math.min(boundary.maxY - player.size / 2, touch.clientY - rect.top));
            });
        }

        // 開始遊戲
        function startGame() {
            console.log("Starting game...");
            menu.style.display = 'none';
            canvas.style.display = 'block';
            scoreDisplay.style.display = 'inline-block';
            buffsDisplay.style.display = 'inline-block';
            timerDisplay.style.display = 'inline-block';
            comboDisplay.style.display = 'block';

            score = 0;
            wineBuff = false;
            fireKillBuff = 0;
            ancientSwordDurability = 0;
            comboCount = 0;
            timeLeft = 60;
            gameActive = true;
            enemies.length = 0;
            caoAngs.length = 0;
            tigers.length = 0;
            zhuges.length = 0;
            items.length = 0;
            holes.length = 0;
            boundTiger = null;
            generateHoles();
            scoreDisplay.textContent = `分數: ${score}`;
            updateBuffDisplay();
            updateComboDisplay();
            timerDisplay.textContent = `剩餘時間: ${Math.ceil(timeLeft)}`;

            bgm.play().catch(error => console.error("BGM play failed:", error));

            spawnInterval = setInterval(() => {
                const enemyHoleIndex = spawnEnemy();
                if (Math.random() < 0.30) spawnOtherCharacter(enemyHoleIndex);
                if (Math.random() < 0.20) spawnItem();

                timeLeft -= 0.5;
                timerDisplay.textContent = `剩餘時間: ${Math.ceil(timeLeft)}`;
                if (timeLeft <= 0) endGame();
            }, 500);
        }

        // 結束遊戲
        function endGame() {
            gameActive = false;
            clearInterval(spawnInterval);
            canvas.style.display = 'none';
            scoreDisplay.style.display = 'none';
            buffsDisplay.style.display = 'none';
            timerDisplay.style.display = 'none';
            comboDisplay.style.display = 'none';
            nameInput.style.display = 'block';
            finalScoreDisplay.textContent = score;
            boundTiger = null;
            bgm.pause();
            bgm.currentTime = 0;
        }

        // 儲存分數到排行榜
        function saveScore() {
            const name = document.getElementById('playerName').value.trim();
            if (!name) return alert('請輸入名稱！');

            let leaderboardData = JSON.parse(localStorage.getItem('leaderboard') || '[]');
            leaderboardData.push({ name, score });
            leaderboardData.sort((a, b) => b.score - a.score);
            leaderboardData = leaderboardData.slice(0, 10);
            localStorage.setItem('leaderboard', JSON.stringify(leaderboardData));

            nameInput.style.display = 'none';
            showLeaderboard();
        }

        // 顯示排行榜
        function showLeaderboard() {
            console.log("Showing leaderboard...");
            menu.style.display = 'none';
            leaderboard.style.display = 'block';
            const leaderboardData = JSON.parse(localStorage.getItem('leaderboard') || '[]');
            leaderboardList.innerHTML = leaderboardData.length > 0
                ? leaderboardData.map((entry, index) => `${index + 1}. ${entry.name}: ${entry.score}`).join('<br>')
                : '尚無紀錄';
            baoAnimation.style.display = 'block';
            swordAnimation.style.display = 'block';
        }

        // 顯示遊戲說明
        function showInstructions() {
            console.log("Showing instructions...");
            menu.style.display = 'none';
            instructions.style.display = 'block';
            baoAnimation.style.display = 'block';
            swordAnimation.style.display = 'block';
        }

        // 返回主選單
        function backToMenu() {
            leaderboard.style.display = 'none';
            instructions.style.display = 'none';
            menu.style.display = 'block';
            baoAnimation.style.display = 'block';
            swordAnimation.style.display = 'block';
        }

        // 初始化並啟動遊戲主迴圈
        gameLoop();
    </script>
</body>
</html>
